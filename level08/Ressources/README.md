# The way we've solved this

1. After logging into the **level08** user, we can see one new binary file, named `level08`, and one text file, named `token`. So, maybe you ask yourself questions like: "What's the point?" or "What's the trouble with getting the token, when that token is recorded in a file, which is given to you?". So, my dear, I can answer you with one word: "Permissions". Only owner can `cat token` file, and you're, spoiler, not it's owner. According to our tradition, let's check the executable too with the strings utility: `strings level08`. We haven't got something interesting here, so, apparently, we need to find some new methods and tools.
2. After doing some research we've found nice utility, named ltrace - a library call tracer, according to it's man page. Let's try to use it on our executable. `ltrace ./level08` haven't got us anything new. Just some printf function, in which we're not very interested in at the moment. Let's try again, with the input file this time `ltrace ./level08 ./token`. This time, among other result string, we may find that one `strstr("./token", "token")`.
3. If you're acquainted with basics of C or C++ you definitely know, what `strstr` does. So we need to somehow rename our file. We can do that by creating symbolic link to our file `token`. Let's do it `ln -s ~/token /tmp/noket`.
4. Now let's try to start our executable `level08` again with the created symbolic link: `./level08 /tmp/noket`. Finally, we've got access to the **flag08** user.
5. Let's log into **flag08** user, and launch `getflag` command to get the next flag: `25749xKZ8L7DkSCwJkT9dyv6f`.
